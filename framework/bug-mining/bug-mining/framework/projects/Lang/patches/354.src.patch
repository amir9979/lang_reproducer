diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java
index 096107365..74da2b61f 100644
--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java
+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java
@@ -18,12 +18,12 @@ package org.apache.commons.lang3.time;
 
 import java.text.ParseException;
 import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.NoSuchElementException;
-import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -365,21 +365,37 @@ public class DateUtils {
         if (str == null || parsePatterns == null) {
             throw new IllegalArgumentException("Date and Patterns must not be null");
         }
-
-        final TimeZone tz = TimeZone.getDefault();
-        final Locale lcl = locale==null ?Locale.getDefault() : locale;
+        
+        SimpleDateFormat parser;
+        if (locale == null) {
+            parser = new SimpleDateFormat();
+        } else {
+            parser = new SimpleDateFormat("", locale);
+        }
+        
+        parser.setLenient(lenient);
         final ParsePosition pos = new ParsePosition(0);
-
         for (final String parsePattern : parsePatterns) {
-            FastDateParser fdp = new FastDateParser(parsePattern, tz, lcl, null, lenient);
-            try {
-                Date date = fdp.parse(str, pos);
-                if (pos.getIndex() == str.length()) {
-                    return date;
-                }
-                pos.setIndex(0);
+
+            String pattern = parsePattern;
+
+            // LANG-530 - need to make sure 'ZZ' output doesn't get passed to SimpleDateFormat
+            if (parsePattern.endsWith("ZZ")) {
+                pattern = pattern.substring(0, pattern.length() - 1);
+            }
+            
+            parser.applyPattern(pattern);
+            pos.setIndex(0);
+
+            String str2 = str;
+            // LANG-530 - need to make sure 'ZZ' output doesn't hit SimpleDateFormat as it will ParseException
+            if (parsePattern.endsWith("ZZ")) {
+                str2 = str.replaceAll("([-+][0-9][0-9]):([0-9][0-9])$", "$1$2"); 
             }
-            catch(IllegalArgumentException iae) {
+
+            final Date date = parser.parse(str2, pos);
+            if (date != null && pos.getIndex() == str2.length()) {
+                return date;
             }
         }
         throw new ParseException("Unable to parse the date: " + str, -1);
diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
index 3f8d02119..2d469a6b3 100644
--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
@@ -75,7 +75,7 @@ public class FastDateParser implements DateParser, Serializable {
      *
      * @see java.io.Serializable
      */
-    private static final long serialVersionUID = 3L;
+    private static final long serialVersionUID = 2L;
 
     static final Locale JAPANESE_IMPERIAL = new Locale("ja","JP","JP");
 
@@ -85,7 +85,6 @@ public class FastDateParser implements DateParser, Serializable {
     private final Locale locale;
     private final int century;
     private final int startYear;
-    private final boolean lenient;
 
     // derived fields
     private transient Pattern parsePattern;
@@ -107,7 +106,7 @@ public class FastDateParser implements DateParser, Serializable {
      * @param locale non-null locale
      */
     protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale) {
-        this(pattern, timeZone, locale, null, true);
+        this(pattern, timeZone, locale, null);
     }
 
     /**
@@ -122,31 +121,11 @@ public class FastDateParser implements DateParser, Serializable {
      * @since 3.3
      */
     protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale, final Date centuryStart) {
-        this(pattern, timeZone, locale, centuryStart, true);
-    }
-
-    /**
-     * <p>Constructs a new FastDateParser.</p>
-     *
-     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible
-     *  pattern
-     * @param timeZone non-null time zone to use
-     * @param locale non-null locale
-     * @param centuryStart The start of the century for 2 digit year parsing
-     * @param lenient if true, non-standard values for Calendar fields should be accepted;
-     * if false, non-standard values will cause a ParseException to be thrown {@link CalendaretLenient(boolean)}
-     *
-     * @since 3.5
-     */
-    protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale,
-            final Date centuryStart, final boolean lenient) {
         this.pattern = pattern;
         this.timeZone = timeZone;
         this.locale = locale;
-        this.lenient = lenient;
 
         final Calendar definingCalendar = Calendar.getInstance(timeZone, locale);
-
         int centuryStartYear;
         if(centuryStart!=null) {
             definingCalendar.setTime(centuryStart);
@@ -357,7 +336,6 @@ public class FastDateParser implements DateParser, Serializable {
         // timing tests indicate getting new instance is 19% faster than cloning
         final Calendar cal= Calendar.getInstance(timeZone, locale);
         cal.clear();
-        cal.setLenient(lenient);
 
         for(int i=0; i<strategies.length;) {
             final Strategy strategy= strategies[i++];
