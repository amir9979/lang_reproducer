diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
index 62f357760..7b20903eb 100644
--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
@@ -31,6 +31,7 @@ import java.util.List;
 import java.util.ListIterator;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.TimeZone;
 import java.util.TreeSet;
@@ -91,16 +92,7 @@ public class FastDateParser implements DateParser, Serializable {
     // derived fields
     private transient List<StrategyAndWidth> patterns;
 
-    // comparator used to sort regex alternatives
-    // alternatives should be ordered longer first, and shorter last. ('february' before 'feb')
-    // all entries must be lowercase by locale.
-    private static final Comparator<String> LONGER_FIRST_LOWERCASE = new Comparator<String>() {
-        @Override
-        public int compare(String left, String right) {
-            return right.compareTo(left);
-        }
-    };
-
+    
     /**
      * <p>Constructs a new FastDateParser.</p>
      * 
@@ -460,29 +452,43 @@ public class FastDateParser implements DateParser, Serializable {
         return sb;
     }
 
+    /**
+     * alternatives should be ordered longer first, and shorter last.  comparisons should be case insensitive.
+     */
+    private static final Comparator<Map.Entry<String, Integer>> ALTERNATIVES_ORDERING = new Comparator<Map.Entry<String, Integer>>() {
+        @Override
+        public int compare(Map.Entry<String, Integer> left, Map.Entry<String, Integer> right) {
+            int v = left.getValue() - right.getValue();
+            if (v != 0) {
+                return v;
+            }
+            return right.getKey().compareToIgnoreCase(left.getKey());
+        }
+    };
+
     /**
      * Get the short and long values displayed for a field
      * @param cal The calendar to obtain the short and long values
      * @param locale The locale of display names
      * @param field The field of interest
      * @param regex The regular expression to build
-     * @return The map of string display names to field values
+     * @param vales The map to fill
      */
-    private static Map<String, Integer> appendDisplayNames(Calendar cal, Locale locale, int field, StringBuilder regex) {
-        Map<String, Integer> values = new HashMap<String, Integer>();
-
-        Map<String, Integer> displayNames = cal.getDisplayNames(field, Calendar.ALL_STYLES, locale);
-        TreeSet<String> sorted = new TreeSet<String>(LONGER_FIRST_LOWERCASE);
-        for (Map.Entry<String, Integer> displayName : displayNames.entrySet()) {
-            String key = displayName.getKey().toLowerCase(locale);
-            if (sorted.add(key)) {
-                values.put(key, displayName.getValue());
+    private static void appendDisplayNames(Calendar cal, Locale locale, int field, 
+            StringBuilder regex, Map<String, Integer> values) {
+
+        Set<Entry<String, Integer>> displayNames = cal.getDisplayNames(field, Calendar.ALL_STYLES, locale).entrySet();
+        TreeSet<Map.Entry<String, Integer>> sort = new TreeSet<Map.Entry<String, Integer>>(ALTERNATIVES_ORDERING);
+        sort.addAll(displayNames);
+
+        for (Map.Entry<String, Integer> entry : sort) {
+            String symbol = entry.getKey();
+            if (symbol.length() > 0) {
+                if (values.put(symbol.toLowerCase(locale), entry.getValue()) == null) {
+                    simpleQuote(regex, symbol).append('|');
+                }
             }
         }
-        for (String symbol : sorted) {
-            simpleQuote(regex, symbol).append('|');
-        }
-        return values;
     }
 
     /**
@@ -697,7 +703,7 @@ public class FastDateParser implements DateParser, Serializable {
      private static class CaseInsensitiveTextStrategy extends PatternStrategy {
         private final int field;
         final Locale locale;
-        private final Map<String, Integer> lKeyValues;
+        private final Map<String, Integer> lKeyValues = new HashMap<String,Integer>();
 
         /**
          * Construct a Strategy that parses a Text field
@@ -711,7 +717,7 @@ public class FastDateParser implements DateParser, Serializable {
             
             StringBuilder regex = new StringBuilder();
             regex.append("((?iu)");
-            lKeyValues = appendDisplayNames(definingCalendar, locale, field, regex);
+            appendDisplayNames(definingCalendar, locale, field, regex, lKeyValues);
             regex.setLength(regex.length()-1);
             regex.append(")");
             createPattern(regex);
@@ -820,18 +826,8 @@ public class FastDateParser implements DateParser, Serializable {
         private static final String GMT_OPTION= "GMT[+-]\\d{1,2}:\\d{2}";
 
         private final Locale locale;
-        private final Map<String, TzInfo> tzNames= new HashMap<String, TzInfo>();
-
-        private static class TzInfo {
-            TimeZone zone;
-            int dstOffset;
-
-            TzInfo(TimeZone tz, boolean useDst) {
-                zone = tz;
-                dstOffset = useDst ?tz.getDSTSavings() :0;
-            }
-        }
-
+        private final Map<String, TimeZone> tzNames= new HashMap<String, TimeZone>();
+ 
         /**
          * Index of zone id
          */
@@ -843,48 +839,30 @@ public class FastDateParser implements DateParser, Serializable {
          * @param locale The Locale
          */
         TimeZoneStrategy(Calendar cal, final Locale locale) {
+
             this.locale = locale;
 
             final StringBuilder sb = new StringBuilder();
-            sb.append("((?iu)" + RFC_822_TIME_ZONE + "|" + GMT_OPTION );
-
-            final Set<String> sorted = new TreeSet<String>(LONGER_FIRST_LOWERCASE);
+            sb.append('(' + RFC_822_TIME_ZONE + "|(?iu)" + GMT_OPTION );
 
             final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();
             for (final String[] zoneNames : zones) {
-                // offset 0 is the time zone ID and is not localized
                 final String tzId = zoneNames[ID];
                 if (tzId.equalsIgnoreCase("GMT")) {
                     continue;
                 }
                 final TimeZone tz = TimeZone.getTimeZone(tzId);
-                // offset 1 is long standard name
-                // offset 2 is short standard name
-                TzInfo standard = new TzInfo(tz, false);
-                TzInfo tzInfo = standard;
-                for (int i = 1; i < zoneNames.length; ++i) {
-                    switch (i) {
-                    case 3: // offset 3 is long daylight savings (or summertime) name
-                            // offset 4 is the short summertime name
-                        tzInfo = new TzInfo(tz, true);
-                        break;
-                    case 5: // offset 5 starts additional names, probably standard time
-                        tzInfo = standard;
+                for(int i= 1; i<zoneNames.length; ++i) {
+                    String zoneName = zoneNames[i];
+                    if (zoneName == null) {
                         break;
                     }
-                    String key = zoneNames[i].toLowerCase(locale);
-                    // ignore the data associated with duplicates supplied in
-                    // the additional names
-                    if (sorted.add(key)) {
-                        tzNames.put(key, tzInfo);
+                    if (tzNames.put(zoneName.toLowerCase(locale), tz) == null) {
+                        simpleQuote(sb.append('|'), zoneName);
                     }
                 }
             }
-            // order the regex alternatives with longer strings first, greedy
-            // match will ensure longest string will be consumed
-            for (String zoneName : sorted) {
-                simpleQuote(sb.append('|'), zoneName);
-            }
+
             sb.append(")");
             createPattern(sb);
         }
@@ -894,17 +872,15 @@ public class FastDateParser implements DateParser, Serializable {
          */
         @Override
         void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {
+            TimeZone tz;
             if (value.charAt(0) == '+' || value.charAt(0) == '-') {
-                TimeZone tz = TimeZone.getTimeZone("GMT" + value);
-                cal.setTimeZone(tz);
+                tz = TimeZone.getTimeZone("GMT" + value);
             } else if (value.regionMatches(true, 0, "GMT", 0, 3)) {
-                TimeZone tz = TimeZone.getTimeZone(value.toUpperCase());
-                cal.setTimeZone(tz);
+                tz = TimeZone.getTimeZone(value.toUpperCase());
             } else {
-                TzInfo tzInfo = tzNames.get(value.toLowerCase(locale));
-                cal.set(Calendar.DST_OFFSET, tzInfo.dstOffset);
-                cal.set(Calendar.ZONE_OFFSET, tzInfo.zone.getRawOffset());
+                tz = tzNames.get(value.toLowerCase(locale));
             }
+            cal.setTimeZone(tz);
         }
     }
     
