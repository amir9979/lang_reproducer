diff --git a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java
index ccf56bac6..7e2e30921 100644
--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java
+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java
@@ -95,6 +95,57 @@ import org.apache.commons.lang.ClassUtils;
  * @version $Id$
  */
 public class ReflectionToStringBuilder extends ToStringBuilder {
+    /**
+     * <p>
+     * A registry of objects used by <code>reflectionToString</code> methods to detect cyclical object references and
+     * avoid infinite loops.
+     * </p>
+     */
+    private static ThreadLocal registry = new ThreadLocal() {
+        protected synchronized Object initialValue() {
+            // The HashSet implementation is not synchronized,
+            // which is just what we need here.
+            return new HashSet();
+        }
+    };
+
+    /**
+     * <p>
+     * Returns the registry of objects being traversed by the <code>reflectionToString</code> methods in the current
+     * thread.
+     * </p>
+     * 
+     * @return Set the registry of objects being traversed
+     */
+    static Set getRegistry() {
+        return (Set) registry.get();
+    }
+
+    /**
+     * <p>
+     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid
+     * infinite loops.
+     * </p>
+     * 
+     * @param value
+     *            The object to lookup in the registry.
+     * @return boolean <code>true</code> if the registry contains the given object.
+     */
+    static boolean isRegistered(Object value) {
+        return getRegistry().contains(value);
+    }
+
+    /**
+     * <p>
+     * Registers the given object. Used by the reflection methods to avoid infinite loops.
+     * </p>
+     * 
+     * @param value
+     *            The object to register.
+     */
+    static void register(Object value) {
+        getRegistry().add(value);
+    }
 
     /**
      * <p>
@@ -411,6 +462,22 @@ public class ReflectionToStringBuilder extends ToStringBuilder {
         return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();
     }
 
+    /**
+     * <p>
+     * Unregisters the given object.
+     * </p>
+     * 
+     * <p>
+     * Used by the reflection methods to avoid infinite loops.
+     * </p>
+     * 
+     * @param value
+     *            The object to unregister.
+     */
+    static void unregister(Object value) {
+        getRegistry().remove(value);
+    }
+
     /**
      * Whether or not to append static fields.
      */
@@ -590,29 +657,60 @@ public class ReflectionToStringBuilder extends ToStringBuilder {
      *            The class of object parameter
      */
     protected void appendFieldsIn(Class clazz) {
-        if (clazz.isArray()) {
-            this.reflectionAppendArray(this.getObject());
+        if (isRegistered(this.getObject())) {
+            // The object has already been appended, therefore we have an
+            // object cycle.
+            // Append a simple Object.toString style string. The field name is
+            // already appended at this point.
+            this.appendAsObjectToString(this.getObject());
             return;
         }
-        Field[] fields = clazz.getDeclaredFields();
-        AccessibleObject.setAccessible(fields, true);
-        for (int i = 0; i < fields.length; i++) {
-            Field field = fields[i];
-            String fieldName = field.getName();
-            if (this.accept(field)) {
-                try {
-                    // Warning: Field.get(Object) creates wrappers objects
-                    // for primitive types.
-                    Object fieldValue = this.getValue(field);
-                    this.append(fieldName, fieldValue);
-                } catch (IllegalAccessException ex) {
-                    //this can't happen. Would get a Security exception
-                    // instead
-                    //throw a runtime exception in case the impossible
-                    // happens.
-                    throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());
+        try {
+            this.registerObject();
+            if (clazz.isArray()) {
+                this.reflectionAppendArray(this.getObject());
+                return;
+            }
+            Field[] fields = clazz.getDeclaredFields();
+            AccessibleObject.setAccessible(fields, true);
+            for (int i = 0; i < fields.length; i++) {
+                Field field = fields[i];
+                String fieldName = field.getName();
+                if (this.accept(field)) {
+                    try {
+                        // Warning: Field.get(Object) creates wrappers objects
+                        // for primitive types.
+                        Object fieldValue = this.getValue(field);
+                        if (isRegistered(fieldValue) && !field.getType().isPrimitive()) {
+                            // A known field value has already been appended,
+                            // therefore we have an object cycle,
+                            // append a simple Object.toString style string.
+                            this.getStyle().appendFieldStart(this.getStringBuffer(), fieldName);
+                            this.appendAsObjectToString(fieldValue);
+                            this.getStyle().appendFieldEnd(this.getStringBuffer(), fieldName);
+                            // The recursion out of
+                            // builder.append(fieldName, fieldValue);
+                            // below will append the field
+                            // end marker.
+                        } else {
+                            try {
+                                this.registerObject();
+                                this.append(fieldName, fieldValue);
+                            } finally {
+                                this.unregisterObject();
+                            }
+                        }
+                    } catch (IllegalAccessException ex) {
+                        // this can't happen. Would get a Security exception
+                        // instead
+                        // throw a runtime exception in case the impossible
+                        // happens.
+                        throw new InternalError("Unexpected IllegalAccessException: " + ex.getMessage());
+                    }
                 }
             }
+        } finally {
+            this.unregisterObject();
         }
     }
 
@@ -691,6 +789,15 @@ public class ReflectionToStringBuilder extends ToStringBuilder {
         return this;
     }
 
+    /**
+     * <p>
+     * Registers this builder's source object to avoid infinite loops when processing circular object references.
+     * </p>
+     */
+    void registerObject() {
+        register(this.getObject());
+    }
+
     /**
      * <p>
      * Sets whether or not to append static fields.
@@ -765,4 +872,12 @@ public class ReflectionToStringBuilder extends ToStringBuilder {
         return super.toString();
     }
 
+    /**
+     * <p>
+     * Unregisters this builder's source object to avoid infinite loops when processing circular object references.
+     * </p>
+     */
+    void unregisterObject() {
+        unregister(this.getObject());
+    }
 }
diff --git a/src/java/org/apache/commons/lang/builder/ToStringStyle.java b/src/java/org/apache/commons/lang/builder/ToStringStyle.java
index 94637519e..5de41cddc 100644
--- a/src/java/org/apache/commons/lang/builder/ToStringStyle.java
+++ b/src/java/org/apache/commons/lang/builder/ToStringStyle.java
@@ -19,9 +19,7 @@ package org.apache.commons.lang.builder;
 import java.io.Serializable;
 import java.lang.reflect.Array;
 import java.util.Collection;
-import java.util.HashSet;
 import java.util.Map;
-import java.util.Set;
 
 import org.apache.commons.lang.ClassUtils;
 import org.apache.commons.lang.ObjectUtils;
@@ -96,78 +94,6 @@ public abstract class ToStringStyle implements Serializable {
      */
     public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();
     
-    /**
-     * <p>
-     * A registry of objects used by <code>reflectionToString</code> methods
-     * to detect cyclical object references and avoid infinite loops.
-     * </p>
-     */
-    private static ThreadLocal registry = new ThreadLocal() {
-        protected synchronized Object initialValue() {
-            // The HashSet implementation is not synchronized,
-            // which is just what we need here.
-            return new HashSet();
-        }
-    };
-
-    /**
-     * <p>
-     * Returns the registry of objects being traversed by the <code>reflectionToString</code>
-     * methods in the current thread.
-     * </p>
-     * 
-     * @return Set the registry of objects being traversed
-     */
-    static Set getRegistry() {
-        return (Set) registry.get();
-    }
-
-    /**
-     * <p>
-     * Returns <code>true</code> if the registry contains the given object.
-     * Used by the reflection methods to avoid infinite loops.
-     * </p>
-     * 
-     * @param value
-     *                  The object to lookup in the registry.
-     * @return boolean <code>true</code> if the registry contains the given
-     *             object.
-     */
-    static boolean isRegistered(Object value) {
-        return getRegistry().contains(value);
-    }
-
-    /**
-     * <p>
-     * Registers the given object. Used by the reflection methods to avoid
-     * infinite loops.
-     * </p>
-     * 
-     * @param value
-     *                  The object to register.
-     */
-    static void register(Object value) {
-        if (value != null) {
-            getRegistry().add(value);
-        }
-    }
-
-    /**
-     * <p>
-     * Unregisters the given object.
-     * </p>
-     * 
-     * <p>
-     * Used by the reflection methods to avoid infinite loops.
-     * </p>
-     * 
-     * @param value
-     *                  The object to unregister.
-     */
-    static void unregister(Object value) {
-        getRegistry().remove(value);
-    }
-
     /**
      * Whether to use the field names, the default is <code>true</code>.
      */
@@ -346,7 +272,6 @@ public abstract class ToStringStyle implements Serializable {
             removeLastFieldSeparator(buffer);
         }
         appendContentEnd(buffer);
-        unregister(object);
     }
 
     /**
@@ -418,14 +343,11 @@ public abstract class ToStringStyle implements Serializable {
      * @param detail  output detail or not
      */
     protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {
-        if (isRegistered(value)
+        if (ReflectionToStringBuilder.isRegistered(value)
             && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {
-           appendCyclicObject(buffer, fieldName, value);
-           return;
-        }   
-           register(value);
-try {
-        if (value instanceof Collection) {
+            ObjectUtils.appendIdentityToString(buffer, value);
+
+        } else if (value instanceof Collection) {
             if (detail) {
                 appendDetail(buffer, fieldName, (Collection) value);
             } else {
@@ -503,31 +425,12 @@ try {
             }
 
         } else {
-                if (detail) {
-                    appendDetail(buffer, fieldName, value);
-                } else {
-                    appendSummary(buffer, fieldName, value);
-                }
-        }
-            } finally {
-                unregister(value);
+            if (detail) {
+                appendDetail(buffer, fieldName, value);
+            } else {
+                appendSummary(buffer, fieldName, value);
             }
-    }
-    
-    /**
-     * <p>Append to the <code>toString</code> an <code>Object</code>
-     * value that has been detected to participate in a cycle. This
-     * implementation will print the standard string value of the value.</p>
-     * 
-     * @param buffer  the <code>StringBuffer</code> to populate
-     * @param fieldName  the field name, typically not used as already appended
-     * @param value  the value to add to the <code>toString</code>,
-     *  not <code>null</code>
-     *  
-     * @since 2.2
-     */
-    protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {
-       ObjectUtils.appendIdentityToString(buffer, value);
+        }
     }
 
     /**
@@ -1398,7 +1301,6 @@ try {
      */
     protected void appendClassName(StringBuffer buffer, Object object) {
         if (useClassName && object != null) {
-        	register(object);
             if (useShortClassName) {
                 buffer.append(getShortClassName(object.getClass()));
             } else {
@@ -1415,7 +1317,6 @@ try {
      */
     protected void appendIdentityHashCode(StringBuffer buffer, Object object) {
         if (this.isUseIdentityHashCode() && object!=null) {
-        	register(object);
             buffer.append('@');
             buffer.append(Integer.toHexString(System.identityHashCode(object)));
         }
