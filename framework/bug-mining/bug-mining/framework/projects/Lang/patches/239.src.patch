diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java
index fa0674666..492c4f363 100644
--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java
+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java
@@ -22,7 +22,6 @@ import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Iterator;
-import java.util.Locale;
 import java.util.NoSuchElementException;
 
 /**
@@ -264,32 +263,9 @@ public class DateUtils {
      * @throws ParseException if none of the date patterns were suitable (or there were none)
      */
     public static Date parseDate(String str, String... parsePatterns) throws ParseException {
-        return parseDate(str, null, parsePatterns);
+        return parseDateWithLeniency(str, parsePatterns, true);
     }
     
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Parses a string representing a date by trying a variety of different parsers,
-     * using the default date format symbols for the given locale.</p>
-     * 
-     * <p>The parse will try each parse pattern in turn.
-     * A parse is only deemed successful if it parses the whole of the input string.
-     * If no parse patterns match, a ParseException is thrown.</p>
-     * The parser will be lenient toward the parsed date.
-     * 
-     * @param str  the date to parse, not null
-     * @param locale the locale whose date format symbols should be used. If <code>null</code>,
-     * the system locale is used (as per {@link #parseDate(String, String...)}).
-     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
-     * @return the parsed date
-     * @throws IllegalArgumentException if the date string or pattern array is null
-     * @throws ParseException if none of the date patterns were suitable (or there were none)
-     * @since 3.2
-     */
-    public static Date parseDate(String str, Locale locale, String... parsePatterns) throws ParseException {
-        return parseDateWithLeniency(str, locale, parsePatterns, true);
-    }    
-
   //-----------------------------------------------------------------------
     /**
      * <p>Parses a string representing a date by trying a variety of different parsers.</p>
@@ -307,31 +283,9 @@ public class DateUtils {
      * @since 2.5
      */
     public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {
-        return parseDateStrictly(str, null, parsePatterns);
+        return parseDateWithLeniency(str, parsePatterns, false);
     }
 
-    /**
-     * <p>Parses a string representing a date by trying a variety of different parsers,
-     * using the default date format symbols for the given locale..</p>
-     * 
-     * <p>The parse will try each parse pattern in turn.
-     * A parse is only deemed successful if it parses the whole of the input string.
-     * If no parse patterns match, a ParseException is thrown.</p>
-     * The parser parses strictly - it does not allow for dates such as "February 942, 1996". 
-     * 
-     * @param str  the date to parse, not null
-     * @param locale the locale whose date format symbols should be used. If <code>null</code>,
-     * the system locale is used (as per {@link #parseDateStrictly(String, String...)}).
-     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
-     * @return the parsed date
-     * @throws IllegalArgumentException if the date string or pattern array is null
-     * @throws ParseException if none of the date patterns were suitable
-     * @since 3.2
-     */
-    public static Date parseDateStrictly(String str, Locale locale, String... parsePatterns) throws ParseException {
-        return parseDateWithLeniency(str, null, parsePatterns, false);
-    }    
-
     /**
      * <p>Parses a string representing a date by trying a variety of different parsers.</p>
      * 
@@ -340,8 +294,6 @@ public class DateUtils {
      * If no parse patterns match, a ParseException is thrown.</p>
      * 
      * @param str  the date to parse, not null
-     * @param locale the locale to use when interpretting the pattern, can be null in which
-     * case the default system locale is used
      * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
      * @param lenient Specify whether or not date/time parsing is to be lenient.
      * @return the parsed date
@@ -350,18 +302,12 @@ public class DateUtils {
      * @see java.util.Calender#isLenient()
      */
     private static Date parseDateWithLeniency(
-            String str, Locale locale, String[] parsePatterns, boolean lenient) throws ParseException {
+            String str, String[] parsePatterns, boolean lenient) throws ParseException {
         if (str == null || parsePatterns == null) {
             throw new IllegalArgumentException("Date and Patterns must not be null");
         }
         
-        SimpleDateFormat parser;
-        if (locale == null) {
-            parser = new SimpleDateFormat();
-        } else {
-            parser = new SimpleDateFormat("", locale);
-        }
-        
+        SimpleDateFormat parser = new SimpleDateFormat();
         parser.setLenient(lenient);
         ParsePosition pos = new ParsePosition(0);
         for (String parsePattern : parsePatterns) {
